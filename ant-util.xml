<?xml version="1.0" encoding="UTF-8" ?>
<project name="ant-util" basedir="./" xmlns:antcontrib="antlib:net.sf.antcontrib">

	<antcontrib:osfamily property="os.family" />

	<macrodef name="abspath">
		<attribute name="path" description="the path to get the absolute dir from" />
		<attribute name="property" description="The property to set with the value." />
		<sequential>
			<!-- Grab data past @{root} in @{full-path}. -->
			<antcontrib:var name="@{property}" unset="true" />
			<property name="@{property}" location="@{path}" />
			<antcontrib:var name="@{property}" value="${@{property}}" />
		</sequential>
	</macrodef>

	<scriptdef name="relpath-js" language="javascript">
		  <attribute name="property"/>
		  <attribute name="from"/>
		  <attribute name="to"/>
		  <![CDATA[
			  try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
		      // Imports: Helper classes for Files
		      importClass(Packages.org.apache.tools.ant.util.FileUtils);
		      importClass(Packages.java.io.File);
		      importClass(Packages.java.lang.System);
		     
		      // Access to the attributes
		      propName = attributes.get("property");
		      baseFile = new File(attributes.get("to"));
		      file     = new File(attributes.get("from"));
		      // The relative
		      relPath = FileUtils.getRelativePath(file, baseFile);
		      if (!file.isDirectory()) {
		          relPath = (relPath.length() >= 3) ? relPath.substring(3) : relPath;
		      }
		      relPath += "/";
		
		      // Store the result in a property
		      project.setNewProperty(propName, relPath);
		  ]]>
	</scriptdef>
	
	<macrodef name="relpath">
	  <attribute name="property"/>
	  <attribute name="from"/>
	  <attribute name="to"/>
		<sequential>
			<antcontrib:var name="___relpathprop" unset="true" />
			<antcontrib:var name="___relpathfrom" unset="true" />
			<antcontrib:var name="___relpathto" unset="true" />
			<property name="___relpathfrom" location="@{from}" />
			<property name="___relpathto" location="@{to}" />
			<relpath-js property="___relpathprop" from="${___relpathfrom}" to="${___relpathto}" />
			<antcontrib:var name="@{property}" value="${___relpathprop}" />			
			<antcontrib:var name="___relpathprop" unset="true" />
			<antcontrib:var name="___relpathfrom" unset="true" />
			<antcontrib:var name="___relpathto" unset="true" />
		</sequential>
	</macrodef>
	
	<macrodef name="required-resource">
		<attribute name="src" />
		<attribute name="dest" />
		<attribute name="verbose" default="true" />
		<attribute name="ignoreerrors" default="false" />
		<sequential>
			<add-required extpath="@{dest}" />
			<antcontrib:if>
				<available file="@{dest}" />
				<then/>
				<else>
					<get src="@{src}" dest="@{dest}" verbose="@{verbose}" ignoreerrors="@{ignoreerrors}" />
				</else>
			</antcontrib:if>
		</sequential>
	</macrodef>
	
	<macrodef name="add-required">
	  	<attribute name="extpath"/>
		<sequential>
			<antcontrib:if>
				<available file="${basedir}/requires.txt"/>
				<then />
				<else>
					<echo file="${basedir}/requires.txt" message="" />
				</else>
			</antcontrib:if>
			<replace-windows-slashes property="___extpath" input="@{extpath}"/>
			<antcontrib:propertyregex override="yes" property="extpath" input="${___extpath}" regexp=".*?/ext/(.*)" select="\1" />
			<antcontrib:var name="requires.content" unset="true" />
			<antcontrib:var name="add-required-path.exists" unset="true" />
			<loadfile property="requires.content" srcFile="${basedir}/requires.txt" />
			<!-- <echo message="${___extpath}"/><echo message=".*${extpath}.*"/> -->
			<antcontrib:propertyregex override="true" property="add-required-path.exists" input="${requires.content}"
				regexp=".*${extpath}.*" select="\1" />
			<antcontrib:if>
				<equals arg1="${add-required-path.exists}" arg2="$${add-required-path.exists}" />
				<then>
					<echo file="${basedir}/requires.txt" append="true">${extpath}${line.separator}</echo>
				</then>
				<else>
					<echo message="requirement is tracked: ${extpath}"/>
				</else>
			</antcontrib:if>
		</sequential>
	</macrodef>

	<scriptdef name="json2xml" language="javascript">
		<attribute name="file"/>
		<attribute name="property"/>
		<![CDATA[
		try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
        importClass(java.io.File);
        importClass(java.io.FileReader);
        importClass(java.io.BufferedReader);
	    file = new File(attributes.get("file"));
        print("Converting JSON to XML"); 
        fr = new FileReader(file);
        br = new BufferedReader(fr);
        // This assumes the file has no line breaks and is one line.
        var json = br.readLine();
        var struct = eval("({json2xml:"+json+"})");
		var json2xml = (typeof exports === 'undefined')? {} : exports; // like commonjs
		(function() {		 
        json2xml.convert = function(o) {
           var toXml = function(v, name, ind) {
              var xml = "";
			  var isInArray = false;
			  //print(name+":"+typeof(v));
              if (v instanceof Array) {
				var arrayName = name;
				if(arrayName == "json2xml") {
					ind += ind+"\t";
					xml += "\n" + ind + "<array>\n";
				} else {
					arrayName = name;
	  				xml += ind + "<"+arrayName+">\n";
	  				xml += ind + "\t<array>\n";
				}
				name = "item";

				for (var i=0, n=v.length; i<n; i++)
                  xml += toXml(v[i], name, "\t"+ind+"");

				if(arrayName == "json2xml") {
					xml += ind + "\t</array>\n";
				} else {
					xml += ind + "\t</array>\n";
					xml += ind + "</"+arrayName+">\n";
				}
				isInArray = false;
              }
              else if (typeof(v) == "object") {
                 var hasChild = false;
                 xml += ind + "<" + name;
                 for (var m in v) {
                    if (m.charAt(0) == "@")
                       xml += " " + m.substr(1) + "=\"" + v[m].toString() + "\"";
                    else
                       hasChild = true;
                 }
                 xml += hasChild ? ">\n" : "/>\n";
                 if (hasChild) {
                    for (var m in v) {
                       if (m == "#text")
                              xml += makeSafe(v[m]);
                       else if (m == "#cdata")
                              xml += "<![CDATA[" + lines(v[m]) + "]"+"]>";
                       else if (m.charAt(0) != "@")
                              xml += toXml(v[m], m, ind+"\t");
                    }
                    xml += (xml.charAt(xml.length-1)=="\n"?ind:"") + "</" + name + ">\n";
                 }
              }
              else { // added special-character transform, but this needs to be better handled [micmath]
				 if(!v) v = "";
                 xml += ind + "<" + name + ">" + makeSafe(v.toString()) +  "</" + name + ">\n";
              }
              return xml;
           },
           xml="";
           for (var m in o) {
             xml += toXml(o[m], m, "");
           }
           return xml;
        }    
		function isNumeric(n) {
		  return !isNaN(parseFloat(n)) && isFinite(n);
		}
        function lines(str) {
                // normalise line endings, all in file will be unixy
                str = str.replace(/\r\n/g, '\n');		                
                return str;
        }        
        function makeSafe(str) {
                // xml special charaters
                str = str.replace(/</g, '&lt;').replace(/&/g, '&amp;');		                
                return lines(str);
        }
	})();
	var retXML = "<json2xml>"+json2xml.convert(struct)+"</json2xml>";
	project.setNewProperty(attributes.get("property"), retXML);
	]]>
	</scriptdef>

	<macrodef name="version-splitter" description="splits a @{version} (3.9.12.333) into @{property}.major (3)  @{property}.minor (9) @{property}.build (12) @{property}.revision (333).  Optionally bumps one of [major|minor|build|revision] if specified.">
	  <attribute name="version"/>
	  <attribute name="property"/>
	  <attribute name="bump" default=""/>
		<sequential>
			<antcontrib:propertyregex override="no" property="@{property}.major" input="@{version}" 
				regexp="(\d)\.+.*" select="\1" />
			<antcontrib:propertyregex override="no" property="@{property}.minor" input="@{version}" 
				regexp="\d+\.(\d+)" select="\1" />
			<antcontrib:propertyregex override="no" property="@{property}.build" input="@{version}" 
				regexp="\d+\.\d+\.(\d+)" select="\1" />
			<property name="@{property}.build" value="00" />
			<antcontrib:propertyregex override="no" property="@{property}.revision" input="@{version}" 
				regexp="\d+\.\d+\.\d+\.(\d+)+.*" select="\1" />
			<property name="@{property}.revision" value="000" />
			<antcontrib:var name="@{property}.long" value="${@{property}.major}.${@{property}.minor}.${@{property}.build}.${@{property}.revision}" />
			<mkdir dir="${temp.dir}"/>
			<echoproperties destfile="${temp.dir}/version.temp.properties" prefix="@{property}"/>
			<antcontrib:var name="@{property}.major" unset="true" />
			<antcontrib:var name="@{property}.minor" unset="true" />
			<antcontrib:var name="@{property}.build" unset="true" />
			<antcontrib:var name="@{property}.revision" unset="true"/>
			<antcontrib:switch value="@{bump}">
				  <case value="major">
				    <propertyfile  file="${temp.dir}/version.temp.properties">
			            <entry key="@{property}.major" type="int" operation="+" value="1" pattern="00"/>
			            <entry key="@{property}.minor" type="int" value="0" pattern="00"/>
			            <entry key="@{property}.build" type="int" value="0" pattern="00"/>
			            <entry key="@{property}.revision" type="int" value="0" pattern="000"/>
				    </propertyfile>
				  	<echo message="bumped major" />
				  </case>
				  <case value="minor">
				    <propertyfile  file="${temp.dir}/version.temp.properties">
			            <entry key="@{property}.major" type="int" operation="+" value="1" pattern="00"/>
			            <entry key="@{property}.build" type="int" value="0" pattern="00"/>
			            <entry key="@{property}.revision" type="int" value="0" pattern="000"/>
				    </propertyfile>
				  	<echo message="bumped minor" />
				  </case>
				  <case value="build">
				    <propertyfile  file="${temp.dir}/version.temp.properties">
			            <entry key="@{property}.build" type="int" operation="+" value="1" pattern="00"/>
			            <entry key="@{property}.revision" type="int" value="0" pattern="000"/>
				    </propertyfile>
				  	<echo message="bumped build" />
				  </case>
				  <case value="revision">
				    <propertyfile  file="${temp.dir}/version.temp.properties">
				            <entry key="@{property}.revision" type="int" operation="+" value="1" pattern="000"/>
				    </propertyfile>
				  	<echo message="bumped revision" />
				  </case>
				  <default>
				    <antcontrib:var file="${temp.dir}/version.temp.properties" />
				  </default>
			</antcontrib:switch>
		    <property file="${temp.dir}/version.temp.properties"/>
			<antcontrib:var name="@{property}.long" value="${@{property}.major}.${@{property}.minor}.${@{property}.build}.${@{property}.revision}" />
			<echo message="Version ${@{property}.long}: Major ${@{property}.major} Minor ${@{property}.minor} Build ${@{property}.build} Revision ${@{property}.revision}"/>
		</sequential>
	</macrodef>
	
	<macrodef name="javac-ecj">
		<attribute name="srcdir" />
		<attribute name="destdir" />
		<attribute name="classpath" default="" />
		<attribute name="compliance" default="1.6" />
		<attribute name="target" default="@{compliance}" />
		<attribute name="source" default="@{compliance}" />
		<attribute name="encoding" default="UTF-8" />
		<attribute name="maxmemory" default="128M" />
		<attribute name="fork" default="true" />
		<sequential>
			<dependency artifactId="ecj-3-8" groupId="cfdistro.lib" version="1.0.0.0" dest="${cfdistro.lib.dir}" type="jar" unzip="false"/>
			<mkdir dir="${temp.dir}" />
			<delete file="${temp.dir}/ecjresult.txt" />
			<antcontrib:trycatch property="foo" reference="bar">
				<try>
					<!-- http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.jdt.doc.isv/guide/jdt_api_compile.htm -->
					<path id="javac-ecj.compile.classpath" path="rt.jar:@{classpath}" />
					<echo message="Compiling @{srcdir} (compliance:@{compliance}) to @{destdir}" />
					<!-- we use the temp file because the cp gets too long for windows sometimes -->
					<echo file="ecj-classpath.txt">-classpath
						"${toString:javac-ecj.compile.classpath}"</echo>
					<antcontrib:trycatch>
					<try><record name="${temp.dir}/ecjresult.txt" action="start"/></try><catch></catch>
					</antcontrib:trycatch>
					<java jar="${cfdistro.lib.dir}/ecj-3-8-1.0.0.0.jar" fork="true"
						classpathref="build.lib.path" maxmemory="@{maxmemory}" failonerror="true">
						<arg value="-@{compliance}" />
						<arg value="-warn:none" />
						<arg value="-d" />
						<arg value='@{destdir}' />
						<arg value="-encoding" />
						<arg value="@{encoding}" />
						<arg value="-target" />
						<arg value="@{target}" />
						<arg value="-source" />
						<arg value="@{source}" />
						<arg line="@ecj-classpath.txt" />
						<arg value="@{srcdir}" />
					</java>
					<antcontrib:trycatch>
					<try><record name="${temp.dir}/ecjresult.txt" action="stop"/></try><catch></catch>
					</antcontrib:trycatch>
					<delete file="ecj-classpath.txt" />
				</try>
				<catch>
					<loadfile srcFile="${temp.dir}/ecjresult.txt" property="ecj.result" failonerror="false" />
					<echo message="Something bad happened while trying to Compile.  Gonna abort now, yo. Sorries."/>
					<property name="baz" refid="bar" />
					<echo>From reference: ${baz}</echo>
					<fail message="error occurred while tyring to compile @{srcdir} : ${ecj.result}" />
				</catch>
			</antcontrib:trycatch>

		</sequential>
	</macrodef>

	<macrodef name="zipdir">
		<attribute name="destfile" />
		<attribute name="sourcedir" />
		<attribute name="compresslevel" default="9" />
		<sequential>
			<property name="zip.cmd" value="zip" />
			<echo>Building zip: @{destfile}</echo>
			<exec executable="${zip.cmd}" dir="@{sourcedir}">
				<arg value="-qR@{compresslevel}" />
				<arg value="@{destfile}" />
				<arg value="*" />
				<arg value="-x *.svn* *.git*" />
			</exec>
		</sequential>
	</macrodef>

	<macrodef name="sanitizePath">
		<attribute name="property" />
		<attribute name="input" />
		<sequential>
			<antcontrib:propertyregex property="@{property}"
				input="@{input}" regexp="[\\|/]" replace="/" global="true" override="yes" />
		</sequential>
	</macrodef>

	<macrodef name="sanitizeContextPath">
		<sequential>
			<antcontrib:propertyregex property="war.contextpath"
				input="${war.contextpath}" regexp="^/?([^/]+)" select="/\1/" global="false"
				override="yes" />
			<antcontrib:propertyregex property="war.contextpath"
				input="${war.contextpath}" regexp="^/{1,}" replace="/" global="true"
				override="yes" />
		</sequential>
	</macrodef>


	<macrodef name="fix-url-slashes">
		<attribute name="property" />
		<sequential>
			<antcontrib:propertyregex property="@{property}"
				input="${@{property}}" regexp="/{1,}" replace="/" global="true"
				override="yes" />
			<antcontrib:propertyregex property="@{property}"
				input="${@{property}}" regexp="http(.)?:/" replace="http\1://"
				global="true" override="yes" />
			<!-- <echo message="fix-url-slashes: ${@{property}}"/>  -->
		</sequential>
	</macrodef>

	<macrodef name="replace-windows-slashes">
		<attribute name="input" />
		<attribute name="property" />
		<sequential>
			<antcontrib:propertyregex property="@{property}"
				input="@{input}" regexp="\\" replace="/" global="true"
				override="yes" defaultValue="@{input}" />
		</sequential>
	</macrodef>

	<macrodef name="load-buildtype-properties">
		<attribute name="buildtype" />
		<sequential>
			<antcontrib:trycatch>
				<try>
					<!-- note="do it twice to catch any already defined deals" -->
					<antcontrib:var file="${basedir}/build.@{buildtype}.properties" />
					<antcontrib:var file="${basedir}/build.@{buildtype}.properties" />
					<echo message="loaded custom properties: ${basedir}/build.@{buildtype}.properties" />
				</try>
				<catch>
					<echo message="no custom properties: ${basedir}/build.@{buildtype}.properties" />
					<antcontrib:trycatch>
						<try>
							<loadproperties srcFile="${cfdistro.basedir}/buildtypes/build.@{buildtype}.properties" />
							<echo message="loaded built-in custom properties: ${cfdistro.basedir}/buildtypes/build.@{buildtype}.properties" />
						</try>
						<catch>
							<echo message="no built-in custom properties: ${cfdistro.basedir}/buildtypes/build.@{buildtype}.properties" />
							<echo message="storing cmdline props for @{buildtype} : ${basedir}/buildtypes/build.@{buildtype}.properties" />
							<storeUserProperties silent="false"/>
							<antcontrib:var name="usersuppliedprops.___echoprefix" unset="true" />
							<antcontrib:var name="usersuppliedprops.list" unset="true" />
							<antcontrib:var name="usersuppliedprops.basedir" unset="true" />
							<antcontrib:var name="usersuppliedprops.dist.root.dir" unset="true" />
							<propertyset id="cmdlineprops">
							    <propertyref prefix="usersuppliedprops."/>
							    <mapper type="glob" from="usersuppliedprops.*" to="*"/>
							</propertyset>
							<echoproperties destfile="${basedir}/build.${build.type}.properties" >
								 <propertyset refid="cmdlineprops" />
							</echoproperties>
						</catch>
					</antcontrib:trycatch>
				</catch>
			</antcontrib:trycatch>
		</sequential>
	</macrodef>

	<macrodef name="load-properties-if-not-defined">
		<attribute name="file" />
		<attribute name="silent" default="false" />
		<sequential>
			<storeUserProperties silent="@{silent}"/>
			<antcontrib:var file="@{file}" />
			<restoreUserProperties silent="@{silent}" />
		</sequential>
	</macrodef>

	<macrodef name="storeUserProperties">
		<attribute name="echoprefix" default="" />
		<attribute name="silent" default="false" />
		<sequential>
			<antcontrib:var name="___echoprefix" value="@{echoprefix}" />
			<removePropsByRegex regex="usersuppliedprops\..*" silent="@{silent}"/>
			<antcontrib:if>
				<equals arg1="@{silent}" arg2="false"/>
				<then><echo message="Storing user supplied properties in usersuppliedprops.*" /></then>
			</antcontrib:if>			
			<script language="javascript" classpathref="build.lib.path">
	     	<![CDATA[
			try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
			importClass(Packages.net.sf.antcontrib.property.Variable);
			var echopre = project.getProperty("___echoprefix");
			xslt = new Variable();
			xslt.project = project;
			props = project.getUserProperties();
			keys = props.keySet().toArray()
			for (i in keys) {
				if(keys[i].substr(0,4) != 'ant.' && keys[i].substr(0,5) != 'user.') {
					if(echopre != '' && keys[i].substr(0,echopre.length()) == echopre) {
						java.lang.System.out.println("Storing:" + keys[i] + "=" + props.get(keys[i]));
					}
					xslt.setName('usersuppliedprops.' + keys[i]);
					xslt.setValue(props.get(keys[i]));
					xslt.execute();
				}
			}
		     ]]>
			</script>
		</sequential>
	</macrodef>

	<macrodef name="restoreUserProperties">
		<attribute name="silent" default="false" />
		<sequential>
			<antcontrib:if>
				<equals arg1="@{silent}" arg2="false"/>
				<then><echo message="Restoring user supplied properties in usersuppliedprops.*" /></then>
			</antcontrib:if>			
			<antcontrib:propertyselector property="usersuppliedprops.list"
				delimiter="," match="usersuppliedprops\.(.*)" select="\1" override="true"
				distinct="true" casesensitive="false" />
			<antcontrib:sortlist property="usersuppliedprops.list" value="${usersuppliedprops.list}" override="true" delimiter="," />
   			<antcontrib:for list="${usersuppliedprops.list}" param="prop">
				<sequential>
					<!-- <echo message="setting: @{prop} to ${usersuppliedprops.@{prop}}" 
						/> -->
					<antcontrib:propertycopy property="@{prop}"
						from="usersuppliedprops.@{prop}" silent="true" override="true" />
				</sequential>
			</antcontrib:for>
			<antcontrib:var name="usersuppliedprops.___echoprefix" unset="true" />
			<antcontrib:var name="usersuppliedprops.list" unset="true" />
			<antcontrib:var name="usersuppliedprops.basedir" unset="true" />
			<antcontrib:var name="usersuppliedprops.dist.root.dir" unset="true" />
		</sequential>
	</macrodef>

	<macrodef name="removePropsByRegex">
		<attribute name="regex" />
		<attribute name="silent" default="false" />
		<sequential>
			<antcontrib:if>
				<equals arg1="@{silent}" arg2="false"/>
				<then><echo message="Removing any properties that match this regex: @{regex}" /></then>
			</antcontrib:if>			
			<antcontrib:propertyselector property="removeByRegex.list" override="true"
				delimiter="," match="(?!user\.|java\.|cfdistro\.|ant\.)+(@{regex})" select="\1" casesensitive="false" />
			<!-- <echo message="Removing: ${removeByRegex.list}" />  -->
			<antcontrib:sortlist property="removeByRegex.list" value="${removeByRegex.list}" override="true" delimiter="," />
			<antcontrib:for list="${removeByRegex.list}" param="prop">
				<sequential>
					<antcontrib:var name="@{prop}" unset="true" />
				</sequential>
			</antcontrib:for>
		</sequential>
	</macrodef>

	<macrodef name="xml-to-property">
		<attribute name="property" default="false" />
		<attribute name="namespacePolicy" default="ignore" />
		<element name="xml" implicit="true" optional="true" />
		<sequential>
            <echoxml-noencode property="@{property}">
				<rawxml><xml /></rawxml>
        	</echoxml-noencode>
			<antcontrib:propertyregex property="@{property}" override="true" input="${@{property}}" 
				regexp="^[\s]+|[\s]+$" replace="" casesensitive="false" />
            <antcontrib:if><isset property="@{property}"/><then/><else><antcontrib:var name="@{property}" value="" /></else></antcontrib:if>
		</sequential>
	</macrodef>

	<macrodef name="checksum-zip">
		<attribute name="srcDir" />
		<attribute name="zipfile" default="${basedir}/checksum.zip" />
		<sequential>
			<mkdir dir="${temp.dir}/checksums" />
			<checksum todir="${temp.dir}/checksums">
				<fileset dir="." />
			</checksum>
			<zip destfile="${dist.dir}/checksums.zip" basedir="${temp.dir}" />
		</sequential>
	</macrodef>

	<macrodef name="ant-gen-run">
		<element name="xml" implicit="true" optional="true"/>
		<text name="text" optional="true"/>
		<sequential>
            <echoxml-noencode property="ant-gen-xml">
                <rawxml>
                    <project basedir="${distro.build.dir}"><import file="${distro.build.dir}/build.xml"/>
                    <target name="antgen">
                        <xml/>@{text}
                    </target></project>
                </rawxml>
            </echoxml-noencode>
    		<echo message="${ant-gen-xml}" />
	        <echo file="${temp.dir}/ant-gen.xml" message="${ant-gen-xml}" append="false"/>
			<xmltask source="${temp.dir}/ant-gen.xml" dest="${temp.dir}/ant-gen.xml" outputter="simple:2" />
	        <ant antfile="${temp.dir}/ant-gen.xml" inheritAll="true" target="antgen" />
	        <delete file="${temp.dir}/ant-gen.xml"/>
		</sequential>
	</macrodef>

    <scriptdef name="set-macrodef-element" language="javascript" classpathref="build.lib.path">
        <attribute name="task" />
        <attribute name="element" />
        <attribute name="value" />
        <![CDATA[
	        try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
	        if (typeof println == 'undefined') this.println = print;  //java8
            var taskname = attributes.get( "task" );
            var value = attributes.get( "value" );
         	printf(self.getRuntimeConfigurableWrapper().getElementTag());
         	printf(self.getRuntimeConfigurableWrapper().getProxy().getRuntimeConfigurableWrapper().getElementTag());
         	var tasks = self.getOwningTarget().getTasks();
         	for(var i in tasks) {
                var task = tasks[i];
    			print(task.getRuntimeConfigurableWrapper().getElementTag() + " = " + taskname);
             	if(task.getRuntimeConfigurableWrapper().getElementTag() == taskname){
                	println("EQUALS");
                   // task.getRuntimeConfigurableWrapper().reconfigure(project);
                    println("kid");
                	task.getRuntimeConfigurableWrapper().addText(value)
                	println(task.getRuntimeConfigurableWrapper().getText());
                	task.init();
                }
		    }
     	]]>
	</scriptdef>

	<scriptdef name="echoxml-noencode" language="javascript" classpathref="build.lib.path">
        <attribute name="property"/>
        <element name="rawxml" className="org.apache.tools.ant.util.XMLFragment" />
        <![CDATA[
	        try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
	        if (typeof println == 'undefined') this.println = print;  //java8
	        importClass(Packages.net.sf.antcontrib.property.Variable);
            importClass(org.w3c.dom.Node);
            importClass(org.apache.tools.ant.util.DOMElementWriter);
            function write(element, out, indent, indentWith) {
        		if(element == null) return;
                // Write child elements and text
                var children = element.getChildNodes();
                var hasChildren = (children.getLength() > 0);
                var hasChildElements = false;
        	    var lSep = java.lang.System.getProperty("line.separator");
        	    var domWriter = new DOMElementWriter(false);
        	    domWriter.openElement(element, out, indent, indentWith, hasChildren);
                if (hasChildren) {
                    for (var i = 0; i < children.getLength(); i++) {
                        var child = children.item(i);
                        switch (child.getNodeType()) {
                        case Node.ELEMENT_NODE:
                            hasChildElements = true;
                            if (i == 0) {
                                out.write(lSep);
                            }
                            write(child, out, indent + 1, indentWith);
                            break;
                        case Node.TEXT_NODE:
                            out.write(child.getNodeValue());
                            break;
                        case Node.COMMENT_NODE:
                            out.write("<!--");
                            out.write(child.getNodeValue());
                            out.write("-->");
                            break;
                        case Node.CDATA_SECTION_NODE:
                            out.write( child.getData() );
                            break;
                        case Node.ENTITY_REFERENCE_NODE:
                            out.write('&');
                            out.write(child.getNodeName());
                            out.write(';');
                            break;
                        case Node.PROCESSING_INSTRUCTION_NODE:
                            out.write("<?");
                            out.write(child.getNodeName());
                            var data = child.getNodeValue();
                            if (data != null && data.length() > 0) {
                                out.write(' ');
                                out.write(data);
                            }
                            out.write("?>");
                            break;
                        default:
                            // Do nothing
                        }
                    }
                    domWriter.closeElement(element, out, indent, indentWith, hasChildElements);
                }
            }    	
    	
        	function dumpFuncs(object){
                var tClass = object.getClass();
                 var methods = tClass.getMethods();
                 for (var i = 0; i < methods.length; i++) {
                     java.lang.System.out.println("public method: " + methods[i]);
                 }
        	}
            //importClass(Packages.org.apache.commons.lang3.builder.ReflectionToStringBuilder);
            var property = attributes.get( "property" );
		    if(elements.get( "rawxml" ) != null) {
        		var xml = elements.get( "rawxml" ).iterator().next();
                var elements = xml.getFragment();
            	var out = new java.io.ByteArrayOutputStream();
            	var writer = new java.io.OutputStreamWriter(out,"UTF-8");
            	write(elements.getFirstChild(),writer,1," ");
		    }
    		if(property != null) {
                varvar = new Variable();
                varvar.project = project;
                varvar.setName(property);
                varvar.setValue(out.toString());
                varvar.execute();           
    		} else {
		        print(out.toString());
		    }
     	]]>
	</scriptdef>

	<macrodef name="hash">
		<attribute name="value"/>
		<attribute name="property"/>
		<sequential>
			<antcontrib:var name="___hashvalue" value="@{value}" />
			<antcontrib:var name="___hashvalueproperty" value="@{property}" />
			<script language="javascript" classpathref="build.lib.path">
	     	<![CDATA[
			try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
			importClass(Packages.net.sf.antcontrib.property.Variable);
			var value = project.getProperty("___hashvalue");
			var valueproperty = project.getProperty("___hashvalueproperty");
			varvar = new Variable();
			varvar.project = project;
			varvar.setName(valueproperty);
			varvar.setValue(value.hashCode());
			varvar.execute();			
		     ]]>
			</script>
			<antcontrib:var name="___hashvalue" unset="true" />
			<antcontrib:var name="___hashvalueproperty" unset="true" />
		</sequential>
	</macrodef>

	<macrodef name="fail-if-not-available">
		<attribute name="file"/>
		<attribute name="message"/>
		<sequential>
			<antcontrib:if>
			<available file="@{file}" />
			<then/>
			<else><fail message="@{message}" /></else>
			</antcontrib:if>
		</sequential>
	</macrodef>
		
	<macrodef name="safestring">
		<attribute name="value"/>
		<attribute name="property"/>
		<sequential>
			<antcontrib:var name="___hashvalue" value="@{value}" />
			<antcontrib:var name="___hashvalueproperty" value="@{property}" />
			<script language="javascript" classpathref="build.lib.path">
	     	<![CDATA[
			try{ load("nashorn:mozilla_compat.js"); } catch (e) {}; //java8
			importClass(Packages.net.sf.antcontrib.property.Variable);
			var value = project.getProperty("___hashvalue");
			var valueproperty = project.getProperty("___hashvalueproperty");
			varvar = new Variable();
			varvar.project = project;
			varvar.setName(valueproperty);
			varvar.setValue(value.replaceAll("[^A-z0-9]","_"));
			varvar.execute();			
		     ]]>
			</script>
			<antcontrib:var name="___hashvalue" unset="true" />
			<antcontrib:var name="___hashvalueproperty" unset="true" />
		</sequential>
	</macrodef>
	
	<macrodef name="replace-attributes">
		<attribute name="string" />
		<attribute name="propertyname" />
		<sequential>
			<antcontrib:var name="@{propertyname}" value="@{string}" />
			<antcontrib:propertyselector property="__dirs" match="(.*\.dir)" select="\1"/>
			<antcontrib:for list="${__dirs}" param="dir">
				<sequential>
					<antcontrib:var name="__dir" value="@{dir}" />
					<replace-windows-slashes property="___dirpath" input="${@{dir}}"/>
					<antcontrib:propertyregex property="@{propertyname}" override="true" input="@{string}" regexp="@${__dir}@(.*)" replace="${___dirpath}\1" casesensitive="false" />
				</sequential>
			</antcontrib:for>
			<antcontrib:var name="___dirpath" unset="true" />
			<antcontrib:var name="__dirs" unset="true" />
			<antcontrib:var name="__dir" unset="true" />
	</sequential>
	</macrodef>

	<macrodef name="add-system-path">
		<attribute name="path" />
		<attribute name="keyword" default="@{path}" />
		<sequential>
			<!--
			add to windows path:
			   	reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v Path /t REG_EXPAND_SZ /d "%path%;c:\test" /f
			   	2.run:
			   	nircmd sysrefresh
			-->
			<property environment="env"/>
			<echo message="${env.PATH}"/>
			<antcontrib:propertyregex override="true" property="add-system-path.path.exists" input="${env.PATH}"
				regexp="${path.separator}?([^${path.separator}]*@{keyword})" select="\1"/>
			<antcontrib:if>
				<equals arg1="${add-system-path.path.exists}" arg2="$${add-system-path.path.exists}" />
				<then>
					<echo message="Not found in path: @{keyword}"/>
					<echo message="Adding path: @{path}"/>
					<antcontrib:switch value="${os.name}">
						<case value="Mac OS X">
							<loadfile property="profile.file.content" srcFile="${user.home}/.profile" />
							<echo message="${profile.file.content}" />
							<antcontrib:propertyregex override="true" property="add-system-path.path.exists" input="${profile.file.content}"
								regexp="${path.separator}?([^${path.separator}]*@{keyword})" select="\1"/>
							<antcontrib:if>
								<equals arg1="${add-system-path.path.exists}" arg2="$${add-system-path.path.exists}" />
								<then>
									<echo message="Adding path to ${user.home}/.profile"/>
									<echo file="${user.home}/.profile" append="true">${line.separator}# Adding cfdistro path${line.separator}<![CDATA[PATH="@{path}:$PATH"]]>${line.separator}export PATH${line.separator}</echo>
								</then>
								<else>
									<echo message="Path exists in ${user.home}/.profile.  Try starting a new terminal so it takes effect."/>
								</else>
							</antcontrib:if>
						</case>
						<case value="Linux">
							<exec spawn="true" executable="kill">
								<arg line="-9" />
								<arg line="${pid.out}" />
							</exec>
						</case>
						<case value="Windows">
							<exec spawn="true" executable="taskkill">
								<arg line="/PID ${pid.out}" />
								<arg line="/F" />
							</exec>
						</case>
						<case value="Windows 7">
							<exec spawn="true" executable="taskkill">
								<arg line="/PID ${pid.out}" />
								<arg line="/F" />
							</exec>
						</case>
						<default>
							<fail message="Um, the os '${os.name}' is unknown to me, esse!" />
						</default>
					</antcontrib:switch>
				</then>
				<else>
					<echo message="Path exists: ${add-system-path.path.exists}"/>
				</else>
			</antcontrib:if>				

		</sequential>
	</macrodef>

	<macrodef name="kill-java"
	          description="Forcefully stop java process">
		<attribute name="name"/>
		<attribute name="jps" default="${java.home}/bin/jps" />
		<sequential>
			<antcontrib:if>
				<available file="@{jps}" />
				<else><echo message="no @{jps} found, cannot find and kill process"/></else>
				<then>
					<!-- Execute the jps and check for any Java process with the provided @{name} attribute -->
					<exec executable="@{jps}" output="pid.out.file" />
					<!-- Load in the name / pid file and strip all information except the PID -->
					<loadfile srcfile="pid.out.file" property="pid.out">
						<filterchain>
							<linecontains>
								<contains value="@{name}"/>
							</linecontains>
							<tokenfilter>
								<deletecharacters chars="@{name}"/>
							</tokenfilter>
							<striplinebreaks/>
						</filterchain>
					</loadfile>
					<antcontrib:propertyregex property="pid.out"
					              input="${pid.out}"
					              regexp="[\s]?(\d+)?.*"
					              select="\1" override="true"
					              casesensitive="false"
					 />
					<antcontrib:if>
						<or>
							<equals arg1="${pid.out}" arg2="" />
							<equals arg1="${pid.out}" arg2="$${pid.out}" />
						</or>
						<then>
							<echo message="No process named @{name} found to kill."/>
						</then>
						<else>
							<echo message="Killing java process with pid ${pid.out} (@{name})"/>
							<antcontrib:switch value="${os.name}">
								<case value="Mac OS X">
									<exec spawn="true" executable="kill">
										<arg line="-9" />
										<arg line="${pid.out}" />
									</exec>
								</case>
								<case value="Linux">
									<exec spawn="true" executable="kill">
										<arg line="-9" />
										<arg line="${pid.out}" />
									</exec>
								</case>
								<case value="Windows">
									<exec spawn="true" executable="taskkill">
										<arg line="/PID ${pid.out}" />
										<arg line="/F" />
									</exec>
								</case>
								<case value="Windows 7">
									<exec spawn="true" executable="taskkill">
										<arg line="/PID ${pid.out}" />
										<arg line="/F" />
									</exec>
								</case>
								<default>
									<fail message="Um, the os '${os.name}' is unknown to me, esse!" />
								</default>
							</antcontrib:switch>
						</else>
					</antcontrib:if>
			  		<delete file="pid.out.file" />
				</then>
			</antcontrib:if>
		</sequential>
	</macrodef>	

	<macrodef name="web-inf-servlet">
 		<attribute name="web.xml.path" default="${war.target.dir}/WEB-INF/web.xml"/>
		<attribute name="servletName" />
		<attribute name="servletClass" />
		<element name="init-params" implicit="false" />
		<element name="servlet-mappings" implicit="false" />
		<sequential>
			<add-required extpath="@{dest}" />
			<antcontrib:if>
				<available file="@{dest}" />
				<then/>
				<else>
					<get src="@{src}" dest="@{dest}" verbose="@{verbose}" ignoreerrors="@{ignoreerrors}" />
				</else>
			</antcontrib:if>
		</sequential>
	</macrodef>

	<macrodef name="web-inf-filter">
 		<attribute name="web.xml.path" default="${war.target.dir}/WEB-INF/web.xml"/>
		<attribute name="filter-name" />
		<attribute name="filter-class" />
		<element name="init-params" implicit="false" />
		<element name="filter-mappings" implicit="false" />
		<sequential>
			<antcontrib:var name="filters.exist" unset="true" />
	    	<xml-to-property property="__initparams"><init-params/></xml-to-property>
	    	<echo>${__initparams}</echo>
			<xmltask source="@{web.xml.path}" dest="@{web.xml.path}">
				<xmlcatalog refId="commonDTDs" />
				<remove path="web-app/filter[filter-name/text()='@{filter-name}']"/>
				<copy path="web-app/filter/@filter-name" attrValue="true" property="filters.exist" />
				<insert path="web-app/filter" position="after" if="filters.exist">
				<![CDATA[<filter><filter-name>@{filter-name}</filter-name><filter-class>@{filter-class}</filter-class>${__initparams}</filter>]]></insert>
				<insert path="web-app/servlet[1]" position="before" unless="filters.exist">
				<![CDATA[<filter><filter-name>@{filter-name}</filter-name><filter-class>@{filter-class}</filter-class>${__initparams}</filter>]]></insert>
			</xmltask>
		</sequential>
	</macrodef>
	
	<macrodef name="propertylist">
 		<attribute name="property" />
		<attribute name="separator" default=" " />
		<sequential>
			<antcontrib:propertyselector property="allprops.list"
	                         delimiter=","
	                         match=".*"
	                         select="\0" />
	        <property name="__proplist" value=" " />
			<antcontrib:for list="${allprops.list}" param="prop">
			  <sequential>
			    <antcontrib:propertycopy name="appprop" from="@{prop}" override="true" />
			    <antcontrib:var name="__proplist" value="${__proplist}@{prop}=&quot;${appprop}&quot; " />
			  </sequential>
			</antcontrib:for>
		    <antcontrib:var name="@{property}" value="${__proplist}" />
		    <antcontrib:var name="allprops.list" unset="true" />
		</sequential>
	</macrodef>
	
	<macrodef name="ant-set-log-level">
 		<attribute name="level" />
		<sequential>
			<property name="___antloglevel" value="@{level}"/>
			<script language="javascript" classpathref="build.lib.path">
			    var logger = project.getBuildListeners().firstElement();
			    var verboseMode = project.getProperty( "___antloglevel" );
				try {
		        	logger.setMessageOutputLevel( verboseMode );
				} catch (e) {
				}
			</script>
			<antcontrib:var name="___antloglevel" unset="true"/>
		</sequential>
	</macrodef>
	
	<macrodef name="silent">
 		<element name="stuff" implicit="true" optional="false"/>
		<sequential>
			<ant-set-log-level level="0"/>
			<stuff/>
			<ant-set-log-level level="2"/>
		</sequential>
	</macrodef>
	
	<macrodef name="cmdline-arg-list">
 		<attribute name="property" />
		<attribute name="separator" default=" " />
		<sequential>
			<property name="allpropslist" value="" />
			<antcontrib:propertyselector property="allpropslist"
				delimiter="," match="usersuppliedprops\.(.*)" select="\1" override="true"
				distinct="true" casesensitive="false" />
	        <property name="__proplist" value=" " />
			<antcontrib:for list="${allpropslist}" param="prop">
			  <sequential>
			    <antcontrib:propertycopy name="appprop" from="@{prop}" override="true" />
			    <antcontrib:var name="__proplist" value="${__proplist}@{prop}=&quot;${appprop}&quot; " />
			  </sequential>
			</antcontrib:for>
		    <antcontrib:var name="@{property}" value="${__proplist}" />
		    <antcontrib:var name="allpropslist" unset="true" />
		</sequential>
	</macrodef>
	
	
</project>
